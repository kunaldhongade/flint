// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

/**
 * @title DecisionVerifier
 * @notice Verifies that decisions are signed by a trusted Enclave.
 * Uses a "Register-then-Verify" flow with an off-chain Attestation Service Oracle.
 * 
 * Flow:
 * 1. Enclave generates Quote and Key.
 * 2. Off-chain Attestation Service verifies DCAP Quote and Enclave Code (MRENCLAVE).
 * 3. Attestation Service signs approval: Sign(EnclaveKey, MRENCLAVE, Expiry).
 * 4. Enclave (or Relayer) calls `registerEnclave` with the Service's signature.
 * 5. Contract registers Enclave Key.
 */
contract DecisionVerifier is Initializable, UUPSUpgradeable, OwnableUpgradeable {
    using ECDSA for bytes32;
    using MessageHashUtils for bytes32;

    // Registry of Allowed Measurement Hashes (MRENCLAVE/MRIS)
    // Only these software builds are trusted.
    mapping(bytes32 => bool) public allowedMrenclaves;

    // Registry of Verified Enclave Keys (Ephemeral)
    // EnclaveKey => Expiry Timestamp
    mapping(address => uint256) public verifiedEnclaves;

    // The address of the trusted off-chain DCAP Verifier Service
    address public attestationVerifier;

    event EnclaveRegistered(address indexed enclaveKey, bytes32 indexed mrenclave, uint256 expiry);
    event MrenclaveWhitelisted(bytes32 indexed mrenclave, bool status);
    event AttestationVerifierUpdated(address indexed newVerifier);

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(address _attestationVerifier) public initializer {
        __Ownable_init(msg.sender);
        __UUPSUpgradeable_init();
        require(_attestationVerifier != address(0), "Invalid verifier address");
        attestationVerifier = _attestationVerifier;
    }

    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}

    /**
     * @notice Governance sets the trusted Attestation Verifier Oracle address.
     */
    function setAttestationVerifier(address _attestationVerifier) external onlyOwner {
        require(_attestationVerifier != address(0), "Invalid address");
        attestationVerifier = _attestationVerifier;
        emit AttestationVerifierUpdated(_attestationVerifier);
    }

    /**
     * @notice Governance adds a trusted software measurement (Hash of the TEE Docker image).
     */
    function setAllowedMrenclave(bytes32 mrenclave, bool allowed) external onlyOwner {
        allowedMrenclaves[mrenclave] = allowed;
        emit MrenclaveWhitelisted(mrenclave, allowed);
    }

    /**
     * @notice Registers an Enclave Key using a signature from the trusted Attestation Verifier.
     * @param enclaveKey The ephemeral key generated by the enclave.
     * @param mrenclave The measurement of the enclave code.
     * @param expiry Timestamp when this attestation expires.
     * @param verifierSignature Signature from `attestationVerifier` conforming to verification.
     */
    function registerEnclave(
        address enclaveKey,
        bytes32 mrenclave,
        uint256 expiry,
        bytes memory verifierSignature
    ) external {
        require(expiry > block.timestamp, "Verifier: Attestation expired");
        require(allowedMrenclaves[mrenclave], "Verifier: Invalid software version (MRENCLAVE)");

        // Reconstruct the signed hash: keccak256(enclaveKey, mrenclave, expiry)
        bytes32 payloadHash = keccak256(abi.encodePacked(enclaveKey, mrenclave, expiry));
        bytes32 ethSignedMessageHash = payloadHash.toEthSignedMessageHash();

        address signer = ethSignedMessageHash.recover(verifierSignature);
        require(signer == attestationVerifier, "Verifier: Invalid Attestation Signature");

        verifiedEnclaves[enclaveKey] = expiry;
        emit EnclaveRegistered(enclaveKey, mrenclave, expiry);
    }

    /**
     * @notice Verifies a decision signature against trusted enclaves.
     */
    function verifyDecision(
        bytes32 decisionHash,
        bytes memory signature
    ) external view returns (bool) {
        bytes32 ethSignedMessageHash = decisionHash.toEthSignedMessageHash();
        address signer = ethSignedMessageHash.recover(signature);
        
        // Check if enclave is verified AND not expired
        return verifiedEnclaves[signer] > block.timestamp;
    }
}
